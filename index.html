<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CubePairs Merge & Match - Fun Pattern Matching Puzzle Game</title>

    <!-- Primary Meta Tags -->
    <meta
      name="title"
      content="CubePairs Merge & Match - Fun Pattern Matching Puzzle Game"
    />
    <meta
      name="description"
      content="Challenge yourself with CubePairs, an addictive pattern matching puzzle game. Match cube patterns, clear the grid, and test your strategic thinking across multiple difficulty levels."
    />
    <meta
      name="keywords"
      content="puzzle game, pattern matching, brain teaser, strategy game, cube game, logic puzzle, online game, free browser game"
    />
    <meta name="author" content="Danrui Wang" />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Quicksand:wght@500;700&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --primary-color: #6366f1;
        --secondary-color: #4f46e5;
        --background-color: #1e293b;
        --surface-color: #ffffff;
        --text-color: #1e293b;
        --accent-color: #22c55e;
        --error-color: #ef4444;
      }

      body {
        font-family: "Poppins", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: var(--background-color);
        margin: 0;
        padding: 40px 20px;
        line-height: 1.6;
        color: var(--text-color);
        min-height: 100vh;
      }

      .game-container {
        background: var(--surface-color);
        padding: 2rem;
        border-radius: 16px;
        box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1),
          0 2px 4px -2px rgb(0 0 0 / 0.1);
        max-width: 600px;
        width: 100%;
      }

      .game-title {
        font-family: "Quicksand", sans-serif;
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--text-color);
        margin-bottom: 1.5rem;
        text-align: center;
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--secondary-color)
        );
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .difficulty-buttons {
        display: flex;
        gap: 12px;
        margin-bottom: 2rem;
        flex-wrap: wrap;
        justify-content: center;
      }

      .difficulty-btn {
        padding: 0.75rem 1.5rem;
        font-family: "Poppins", sans-serif;
        font-size: 1rem;
        font-weight: 600;
        background-color: var(--surface-color);
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
        cursor: pointer;
        border-radius: 9999px;
        transition: all 0.2s ease;
      }

      .difficulty-btn:hover {
        background-color: var(--primary-color);
        color: white;
        transform: translateY(-2px);
      }

      .difficulty-btn.active {
        background-color: var(--primary-color);
        color: white;
      }

      #move-counter {
        font-family: "Quicksand", sans-serif;
        font-size: 1.5rem;
        margin-bottom: 1.5rem;
        font-weight: 700;
        color: var(--primary-color);
        text-align: center;
      }

      #grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 12px;
        max-width: 400px;
        margin: 0 auto 2rem auto;
      }

      .grid-cell {
        display: flex;
        justify-content: center;
        align-items: center;
        aspect-ratio: 1;
        border: 2px solid var(--primary-color);
        border-radius: 12px;
        cursor: pointer;
        background-color: var(--surface-color);
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .grid-cell:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .grid-cell table {
        border-spacing: 3px;
      }

      .grid-cell td {
        width: 20px;
        height: 20px;
        border-radius: 4px;
      }

      .grid-cell .filled {
        background-color: var(--primary-color);
      }

      .grid-cell .empty {
        background-color: #e2e8f0;
      }

      .selected {
        background-color: #fef9c3 !important;
        border-color: var(--secondary-color) !important;
      }

      #restart-btn {
        display: block;
        margin: 0 auto;
        padding: 1rem 2rem;
        font-family: "Poppins", sans-serif;
        font-size: 1rem;
        font-weight: 600;
        background-color: var(--accent-color);
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 9999px;
        transition: all 0.2s ease;
      }

      #restart-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .game-rules {
        background-color: var(--surface-color);
        border: 2px solid #e2e8f0;
        border-radius: 12px;
        padding: 1.5rem;
        margin-top: 2rem;
        text-align: center;
        font-size: 1rem;
        line-height: 1.6;
        color: var(--text-color);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      @media screen and (max-width: 768px) {
        .game-title {
          font-size: 2rem;
          margin-bottom: 1rem;
        }

        .game-container {
          padding: 1.5rem;
          margin: 1rem;
        }

        .difficulty-buttons {
          gap: 8px;
          margin-bottom: 1.5rem;
        }

        .difficulty-btn {
          padding: 0.6rem 1.2rem;
          font-size: 0.9rem;
        }

        #grid {
          gap: 10px;
          max-width: 350px;
        }

        .grid-cell td {
          width: 18px;
          height: 18px;
        }

        .game-rules {
          font-size: 0.9rem;
          padding: 1.25rem;
        }
      }

      @media screen and (max-width: 480px) {
        .game-title {
          font-size: 1.75rem;
        }

        .game-container {
          padding: 1rem;
          margin: 0.5rem;
        }

        .difficulty-buttons {
          gap: 6px;
        }

        .difficulty-btn {
          padding: 0.5rem 1rem;
          font-size: 0.8rem;
        }

        #grid {
          gap: 8px;
          max-width: 300px;
        }

        .grid-cell td {
          width: 15px;
          height: 15px;
        }

        #move-counter {
          font-size: 1.25rem;
          margin-bottom: 1rem;
        }

        #restart-btn {
          padding: 0.75rem 1.5rem;
          font-size: 0.9rem;
        }
      }

      @media screen and (max-width: 360px) {
        .game-title {
          font-size: 1.5rem;
        }

        .game-container {
          padding: 0.75rem;
        }

        .difficulty-btn {
          padding: 0.4rem 0.8rem;
          font-size: 0.75rem;
        }

        #grid {
          gap: 6px;
          max-width: 260px;
        }

        .grid-cell td {
          width: 12px;
          height: 12px;
        }

        .game-rules {
          font-size: 0.8rem;
          padding: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1 class="game-title">CubePairs Merge & Match</h1>

      <div class="difficulty-buttons">
        <button class="difficulty-btn active" data-difficulty="easy">
          Easy
        </button>
        <button class="difficulty-btn" data-difficulty="medium">Medium</button>
        <button class="difficulty-btn" data-difficulty="hard">Hard</button>
        <button class="difficulty-btn" data-difficulty="impossible">
          Impossible
        </button>
      </div>

      <div id="move-counter">Moves: 0</div>
      <div id="grid"></div>
      <button id="restart-btn">Restart Game</button>

      <div id="game-rules" class="game-rules">
        Select two cells. If they match, both clear. If not, the second cell
        updates to a mix of both patterns. Clear the grid in as few moves as
        possible!
      </div>
    </div>

    <script>
      class GridGame {
        constructor() {
          this.GRID_SIZE = 4;
          this.SHAPES = [
            [
              [1, 1],
              [1, 1],
            ], // All parts present
            [
              [0, 1],
              [1, 1],
            ], // Top-left missing
            [
              [1, 0],
              [1, 1],
            ], // Top-right missing
            [
              [1, 1],
              [0, 1],
            ], // Bottom-left missing
            [
              [1, 1],
              [1, 0],
            ], // Bottom-right missing
            [
              [0, 0],
              [1, 1],
            ], // Top row missing
            [
              [1, 1],
              [0, 0],
            ], // Bottom row missing
            [
              [0, 1],
              [0, 1],
            ], // Left column missing
            [
              [1, 0],
              [1, 0],
            ], // Right column missing
            [
              [0, 1],
              [1, 0],
            ], // Diagonal 1 missing
            [
              [1, 0],
              [0, 1],
            ], // Diagonal 2 missing
            [
              [0, 1],
              [0, 0],
            ], // Top-left and bottom-right missing
            [
              [0, 0],
              [1, 0],
            ], // Top-right and bottom-left missing
            [
              [1, 0],
              [0, 0],
            ], // Only top-right present
            [
              [0, 0],
              [1, 0],
            ], // Only bottom-left present
          ];
          this.EMPTY = [
            [0, 0],
            [0, 0],
          ];

          this.difficulties = {
            easy: {
              rule: () => true,
              description:
                "Select two cells. If they match, both clear. If not, the second cell updates to a mix of both patterns. Clear the grid in as few moves as possible!",
            },
            medium: {
              rule: (row1, col1, row2, col2) =>
                this.isInSameRowColumnOrDiagonal(row1, col1, row2, col2),
              description:
                "Select two cells in the same row, column or diagonal. If they match, both clear. If not, the second cell updates to a mix of both patterns. Clear the grid in as few moves as possible!",
            },
            hard: {
              rule: (row1, col1, row2, col2) =>
                this.isInSameLineOrColumn(row1, col1, row2, col2),
              description:
                "Select two cells in the same row or column. If they match, both clear. If not, the second cell updates to a mix of both patterns. Clear the grid in as few moves as possible!",
            },
            impossible: {
              rule: (row1, col1, row2, col2) =>
                this.isAdjacent(row1, col1, row2, col2),
              description:
                "Select two cells. The second cell must be adjacent to the first. If they match, both clear. If not, the second cell updates to a mix of both patterns. Clear the grid in as few moves as possible!",
            },
          };

          this.currentDifficulty = "easy";
          this.grid = Array(this.GRID_SIZE)
            .fill()
            .map(() =>
              Array(this.GRID_SIZE)
                .fill()
                .map(() => [])
            );
          this.firstRow = -1;
          this.firstCol = -1;
          this.moveCount = 0;

          this.gridElement = document.getElementById("grid");
          this.moveCounterElement = document.getElementById("move-counter");
          this.restartButton = document.getElementById("restart-btn");
          this.gameRules = document.getElementById("game-rules");

          this.setupEventListeners();
          this.initializeGrid();
          this.renderGrid();
          this.updateRules();
        }

        setupEventListeners() {
          this.restartButton.addEventListener("click", () =>
            this.restartGame()
          );

          document.querySelectorAll(".difficulty-btn").forEach((button) => {
            button.addEventListener("click", (e) => {
              document
                .querySelectorAll(".difficulty-btn")
                .forEach((btn) => btn.classList.remove("active"));
              e.target.classList.add("active");
              this.currentDifficulty = e.target.dataset.difficulty;
              this.updateRules();
              this.restartGame();
            });
          });
        }

        updateRules() {
          this.gameRules.textContent =
            this.difficulties[this.currentDifficulty].description;
        }

        isAdjacent(row1, col1, row2, col2) {
          return (
            Math.abs(row1 - row2) <= 1 &&
            Math.abs(col1 - col2) <= 1 &&
            !(row1 === row2 && col1 === col2)
          );
        }

        isInSameLineOrColumn(row1, col1, row2, col2) {
          return row1 === row2 || col1 === col2;
        }

        isInSameRowColumnOrDiagonal(row1, col1, row2, col2) {
          return (
            row1 === row2 ||
            col1 === col2 ||
            Math.abs(row1 - row2) === Math.abs(col1 - col2)
          );
        }

        initializeGrid() {
          const shapeList = [
            ...this.SHAPES,
            this.SHAPES[Math.floor(Math.random() * this.SHAPES.length)],
          ];
          this.shuffleArray(shapeList);

          let shapeIndex = 0;
          for (let i = 0; i < this.GRID_SIZE; i++) {
            for (let j = 0; j < this.GRID_SIZE; j++) {
              this.grid[i][j] = shapeList[shapeIndex++];
            }
          }

          this.moveCount = 0;
          this.updateMoveCounter();
        }

        shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
        }

        renderGrid() {
          this.gridElement.innerHTML = "";
          for (let i = 0; i < this.GRID_SIZE; i++) {
            for (let j = 0; j < this.GRID_SIZE; j++) {
              const cell = document.createElement("div");
              cell.className = "grid-cell";
              cell.dataset.row = i;
              cell.dataset.col = j;
              cell.innerHTML = this.getShapeAsHTML(this.grid[i][j]);
              cell.addEventListener("click", () => this.handleCellClick(i, j));
              this.gridElement.appendChild(cell);
            }
          }
        }

        getShapeAsHTML(shape) {
          if (this.isShapeEqual(shape, this.EMPTY)) {
            return "";
          }

          let html = "<table>";
          for (let i = 0; i < 2; i++) {
            html += "<tr>";
            for (let j = 0; j < 2; j++) {
              html += `<td class="${
                shape[i][j] === 1 ? "filled" : "empty"
              }"></td>`;
            }
            html += "</tr>";
          }
          html += "</table>";
          return html;
        }

        isShapeEqual(shape1, shape2) {
          return shape1.every((row, i) =>
            row.every((cell, j) => cell === shape2[i][j])
          );
        }

        xorShapes(shape1, shape2) {
          return shape1.map((row, i) =>
            row.map((cell, j) => cell ^ shape2[i][j])
          );
        }

        handleCellClick(row, col) {
          const cell = this.gridElement.querySelector(
            `[data-row="${row}"][data-col="${col}"]`
          );

          if (this.isShapeEqual(this.grid[row][col], this.EMPTY)) {
            alert("This cell is already empty!");
            return;
          }

          if (this.firstRow === -1 && this.firstCol === -1) {
            this.firstRow = row;
            this.firstCol = col;
            cell.classList.add("selected");
          } else {
            const firstCell = this.gridElement.querySelector(
              `[data-row="${this.firstRow}"][data-col="${this.firstCol}"]`
            );

            if (
              !this.difficulties[this.currentDifficulty].rule(
                this.firstRow,
                this.firstCol,
                row,
                col
              )
            ) {
              alert("Invalid move!");
              return;
            }

            if (this.firstRow === row && this.firstCol === col) {
              alert("You must select a different cell!");
            } else {
              if (
                this.isShapeEqual(
                  this.grid[this.firstRow][this.firstCol],
                  this.grid[row][col]
                )
              ) {
                this.grid[this.firstRow][this.firstCol] = this.EMPTY;
                this.grid[row][col] = this.EMPTY;
              } else {
                this.grid[row][col] = this.xorShapes(
                  this.grid[this.firstRow][this.firstCol],
                  this.grid[row][col]
                );
              }

              firstCell.innerHTML = this.getShapeAsHTML(
                this.grid[this.firstRow][this.firstCol]
              );
              cell.innerHTML = this.getShapeAsHTML(this.grid[row][col]);

              firstCell.classList.remove("selected");
              cell.classList.remove("selected");

              this.moveCount++;
              this.updateMoveCounter();

              this.firstRow = -1;
              this.firstCol = -1;

              if (this.isGridSolved()) {
                alert("You Win!");
                this.restartGame();
              }
            }
          }
        }

        updateMoveCounter() {
          this.moveCounterElement.textContent = `Moves: ${this.moveCount}`;
        }

        isGridSolved() {
          return this.grid.every((row) =>
            row.every((cell) => this.isShapeEqual(cell, this.EMPTY))
          );
        }

        restartGame() {
          this.firstRow = -1;
          this.firstCol = -1;
          this.initializeGrid();
          this.renderGrid();
        }
      }

      // Initialize the game when the page loads
      new GridGame();
    </script>
  </body>
</html>
